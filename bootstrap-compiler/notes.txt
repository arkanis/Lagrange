# ToDo

x Add try(token_type_t) â†’ token_p function to the parser support code:
	
	Use a try(token_type_t) function in the parser instead of peek_type().
	When it's possible to use this everywhere the parser can automatically
	present the user a list of expected tokens at the position the parser
	failed:
	
	- Every time try() is called it remembers the expected token.
	- When a token is consumed the list is cleared.
	- When the parser failes the list contains all tried tokens at the current position.
	
	This is what we want to show the user in the error message. :)
x Rework grammar: stick to basics for now
x Make sure try() doesn't add the same token twice for the same position	
x Write down complete grammar (see syntax/2016-07-09.txt)
x Change eos behaviour of try(): Ignore line breaks unless try(T_WSNL).
x Change error message format of parser_error(): expected a, b, c after x. This
  way we don't need to write down what the next token the parser got. Avoids the
  problem if we should ignore new lines or not when finding the next token.
- Start of with a simple parser test case
	x Write very simple version of parse_expr() that parses string and int literals
	x Refactor AST allocation and printing functions
	- Write simple automated test case for parsing
- Port entire grammar
- Add token range to AST nodes and support functions:
	- Add token list to AST nodes
	- Add to AST node creation functions
	- Create an parser_error() function that prints the tokens we're at
	- Create a node_error() function that prints the nodes tokens and an error.
	  Usefull to emit errors in passes.
- Write a node_error() function thats like parser_error() but for AST processing.
  It just shows the first line of the AST nodes tokens. Otherwise we would get
  huge error messages on function nodes and the like.
- Reenalble namespaces calls node_alloc(), node_print_recursive()
- Reenalble type calls in node_print_recursive(), node_print_inline()